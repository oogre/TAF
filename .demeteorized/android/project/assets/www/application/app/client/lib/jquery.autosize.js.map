{"version":3,"sources":["meteor://ðŸ’»app/client/lib/jquery.autosize.js"],"names":[],"mappings":"eAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/client/lib/jquery.autosize.js","sourcesContent":["/*!\n\tAutosize 1.18.17\n\tlicense: MIT\n\thttp://www.jacklmoore.com/autosize\n*/\n(function ($) {\n\tvar\n\tdefaults = {\n\t\tclassName: 'autosizejs',\n\t\tid: 'autosizejs',\n\t\tappend: '\\n',\n\t\tcallback: false,\n\t\tresizeDelay: 10,\n\t\tplaceholder: true\n\t},\n\n\t// border:0 is unnecessary, but avoids a bug in Firefox on OSX\n\tcopy = '<textarea tabindex=\"-1\" style=\"position:absolute; top:-999px; left:0; right:auto; bottom:auto; border:0; padding: 0; -moz-box-sizing:content-box; -webkit-box-sizing:content-box; box-sizing:content-box; word-wrap:break-word; height:0 !important; min-height:0 !important; overflow:hidden; transition:none; -webkit-transition:none; -moz-transition:none;\"/>',\n\n\t// line-height is conditionally included because IE7/IE8/old Opera do not return the correct value.\n\ttypographyStyles = [\n\t\t'fontFamily',\n\t\t'fontSize',\n\t\t'fontWeight',\n\t\t'fontStyle',\n\t\t'letterSpacing',\n\t\t'textTransform',\n\t\t'wordSpacing',\n\t\t'textIndent',\n\t\t'whiteSpace'\n\t],\n\n\t// to keep track which textarea is being mirrored when adjust() is called.\n\tmirrored,\n\n\t// the mirror element, which is used to calculate what size the mirrored element should be.\n\tmirror = $(copy).data('autosize', true)[0];\n\n\t// test that line-height can be accurately copied.\n\tmirror.style.lineHeight = '99px';\n\tif ($(mirror).css('lineHeight') === '99px') {\n\t\ttypographyStyles.push('lineHeight');\n\t}\n\tmirror.style.lineHeight = '';\n\n\t$.fn.autosize = function (options) {\n\t\tif (!this.length) {\n\t\t\treturn this;\n\t\t}\n\n\t\toptions = $.extend({}, defaults, options || {});\n\n\t\tif (mirror.parentNode !== document.body) {\n\t\t\t$(document.body).append(mirror);\n\t\t}\n\n\t\treturn this.each(function () {\n\t\t\tvar\n\t\t\tta = this,\n\t\t\t$ta = $(ta),\n\t\t\tmaxHeight,\n\t\t\tminHeight,\n\t\t\tboxOffset = 0,\n\t\t\tcallback = $.isFunction(options.callback),\n\t\t\toriginalStyles = {\n\t\t\t\theight: ta.style.height,\n\t\t\t\toverflow: ta.style.overflow,\n\t\t\t\toverflowY: ta.style.overflowY,\n\t\t\t\twordWrap: ta.style.wordWrap,\n\t\t\t\tresize: ta.style.resize\n\t\t\t},\n\t\t\ttimeout,\n\t\t\twidth = $ta.width(),\n\t\t\ttaResize = $ta.css('resize');\n\n\t\t\tif ($ta.data('autosize')) {\n\t\t\t\t// exit if autosize has already been applied, or if the textarea is the mirror element.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t$ta.data('autosize', true);\n\n\t\t\tif ($ta.css('box-sizing') === 'border-box' || $ta.css('-moz-box-sizing') === 'border-box' || $ta.css('-webkit-box-sizing') === 'border-box'){\n\t\t\t\tboxOffset = $ta.outerHeight() - $ta.height();\n\t\t\t}\n\n\t\t\t// IE8 and lower return 'auto', which parses to NaN, if no min-height is set.\n\t\t\tminHeight = Math.max(parseFloat($ta.css('minHeight')) - boxOffset || 0, $ta.height());\n\n\t\t\t$ta.css({\n\t\t\t\toverflow: 'hidden',\n\t\t\t\toverflowY: 'hidden',\n\t\t\t\twordWrap: 'break-word' // horizontal overflow is hidden, so break-word is necessary for handling words longer than the textarea width\n\t\t\t});\n\n\t\t\tif (taResize === 'vertical') {\n\t\t\t\t$ta.css('resize','none');\n\t\t\t} else if (taResize === 'both') {\n\t\t\t\t$ta.css('resize', 'horizontal');\n\t\t\t}\n\n\t\t\t// getComputedStyle is preferred here because it preserves sub-pixel values, while jQuery's .width() rounds to an integer.\n\t\t\tfunction setWidth() {\n\t\t\t\tvar width;\n\t\t\t\tvar style = window.getComputedStyle ? window.getComputedStyle(ta, null) : null;\n\n\t\t\t\tif (style) {\n\t\t\t\t\twidth = parseFloat(style.width);\n\t\t\t\t\tif (style.boxSizing === 'border-box' || style.webkitBoxSizing === 'border-box' || style.mozBoxSizing === 'border-box') {\n\t\t\t\t\t\t$.each(['paddingLeft', 'paddingRight', 'borderLeftWidth', 'borderRightWidth'], function(i,val){\n\t\t\t\t\t\t\twidth -= parseFloat(style[val]);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twidth = $ta.width();\n\t\t\t\t}\n\n\t\t\t\tmirror.style.width = Math.max(width,0) + 'px';\n\t\t\t}\n\n\t\t\tfunction initMirror() {\n\t\t\t\tvar styles = {};\n\n\t\t\t\tmirrored = ta;\n\t\t\t\tmirror.className = options.className;\n\t\t\t\tmirror.id = options.id;\n\t\t\t\tmaxHeight = parseFloat($ta.css('maxHeight'));\n\n\t\t\t\t// mirror is a duplicate textarea located off-screen that\n\t\t\t\t// is automatically updated to contain the same text as the\n\t\t\t\t// original textarea.  mirror always has a height of 0.\n\t\t\t\t// This gives a cross-browser supported way getting the actual\n\t\t\t\t// height of the text, through the scrollTop property.\n\t\t\t\t$.each(typographyStyles, function(i,val){\n\t\t\t\t\tstyles[val] = $ta.css(val);\n\t\t\t\t});\n\n\t\t\t\t$(mirror).css(styles).attr('wrap', $ta.attr('wrap'));\n\n\t\t\t\tsetWidth();\n\n\t\t\t\t// Chrome-specific fix:\n\t\t\t\t// When the textarea y-overflow is hidden, Chrome doesn't reflow the text to account for the space\n\t\t\t\t// made available by removing the scrollbar. This workaround triggers the reflow for Chrome.\n\t\t\t\tif (window.chrome) {\n\t\t\t\t\tvar width = ta.style.width;\n\t\t\t\t\tta.style.width = '0px';\n\t\t\t\t\tvar ignore = ta.offsetWidth;\n\t\t\t\t\tta.style.width = width;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Using mainly bare JS in this function because it is going\n\t\t\t// to fire very often while typing, and needs to very efficient.\n\t\t\tfunction adjust() {\n\t\t\t\tvar height, originalHeight;\n\n\t\t\t\tif (mirrored !== ta) {\n\t\t\t\t\tinitMirror();\n\t\t\t\t} else {\n\t\t\t\t\tsetWidth();\n\t\t\t\t}\n\n\t\t\t\tif (!ta.value && options.placeholder) {\n\t\t\t\t\t// If the textarea is empty, copy the placeholder text into\n\t\t\t\t\t// the mirror control and use that for sizing so that we\n\t\t\t\t\t// don't end up with placeholder getting trimmed.\n\t\t\t\t\tmirror.value = ($ta.attr(\"placeholder\") || '');\n\t\t\t\t} else {\n\t\t\t\t\tmirror.value = ta.value;\n\t\t\t\t}\n\n\t\t\t\tmirror.value += options.append || '';\n\t\t\t\tmirror.style.overflowY = ta.style.overflowY;\n\t\t\t\toriginalHeight = parseFloat(ta.style.height) || 0;\n\n\t\t\t\t// Setting scrollTop to zero is needed in IE8 and lower for the next step to be accurately applied\n\t\t\t\tmirror.scrollTop = 0;\n\n\t\t\t\tmirror.scrollTop = 9e4;\n\n\t\t\t\t// Using scrollTop rather than scrollHeight because scrollHeight is non-standard and includes padding.\n\t\t\t\theight = mirror.scrollTop;\n\n\t\t\t\tif (maxHeight && height > maxHeight) {\n\t\t\t\t\tta.style.overflowY = 'scroll';\n\t\t\t\t\theight = maxHeight;\n\t\t\t\t} else {\n\t\t\t\t\tta.style.overflowY = 'hidden';\n\t\t\t\t\tif (height < minHeight) {\n\t\t\t\t\t\theight = minHeight;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\theight += boxOffset;\n\n\t\t\t\tif (Math.abs(originalHeight - height) > 1/100) {\n\t\t\t\t\tta.style.height = height + 'px';\n\n\t\t\t\t\t// Trigger a repaint for IE8 for when ta is nested 2 or more levels inside an inline-block\n\t\t\t\t\tmirror.className = mirror.className;\n\n\t\t\t\t\tif (callback) {\n\t\t\t\t\t\toptions.callback.call(ta,ta);\n\t\t\t\t\t}\n\t\t\t\t\t$ta.trigger('autosize.resized');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction resize () {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t\ttimeout = setTimeout(function(){\n\t\t\t\t\tvar newWidth = $ta.width();\n\n\t\t\t\t\tif (newWidth !== width) {\n\t\t\t\t\t\twidth = newWidth;\n\t\t\t\t\t\tadjust();\n\t\t\t\t\t}\n\t\t\t\t}, parseInt(options.resizeDelay,10));\n\t\t\t}\n\n\t\t\tif ('onpropertychange' in ta) {\n\t\t\t\tif ('oninput' in ta) {\n\t\t\t\t\t// Detects IE9.  IE9 does not fire onpropertychange or oninput for deletions,\n\t\t\t\t\t// so binding to onkeyup to catch most of those occasions.  There is no way that I\n\t\t\t\t\t// know of to detect something like 'cut' in IE9.\n\t\t\t\t\t$ta.on('input.autosize keyup.autosize', adjust);\n\t\t\t\t} else {\n\t\t\t\t\t// IE7 / IE8\n\t\t\t\t\t$ta.on('propertychange.autosize', function(){\n\t\t\t\t\t\tif(event.propertyName === 'value'){\n\t\t\t\t\t\t\tadjust();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Modern Browsers\n\t\t\t\t$ta.on('input.autosize', adjust);\n\t\t\t}\n\n\t\t\t// Set options.resizeDelay to false if using fixed-width textarea elements.\n\t\t\t// Uses a timeout and width check to reduce the amount of times adjust needs to be called after window resize.\n\n\t\t\tif (options.resizeDelay !== false) {\n\t\t\t\t$(window).on('resize.autosize', resize);\n\t\t\t}\n\n\t\t\t// Event for manual triggering if needed.\n\t\t\t// Should only be needed when the value of the textarea is changed through JavaScript rather than user input.\n\t\t\t$ta.on('autosize.resize', adjust);\n\n\t\t\t// Event for manual triggering that also forces the styles to update as well.\n\t\t\t// Should only be needed if one of typography styles of the textarea change, and the textarea is already the target of the adjust method.\n\t\t\t$ta.on('autosize.resizeIncludeStyle', function() {\n\t\t\t\tmirrored = null;\n\t\t\t\tadjust();\n\t\t\t});\n\n\t\t\t$ta.on('autosize.destroy', function(){\n\t\t\t\tmirrored = null;\n\t\t\t\tclearTimeout(timeout);\n\t\t\t\t$(window).off('resize', resize);\n\t\t\t\t$ta\n\t\t\t\t\t.off('autosize')\n\t\t\t\t\t.off('.autosize')\n\t\t\t\t\t.css(originalStyles)\n\t\t\t\t\t.removeData('autosize');\n\t\t\t});\n\n\t\t\t// Call adjust in case the textarea already contains text.\n\t\t\tadjust();\n\t\t});\n\t};\n}(jQuery || $)); // jQuery or jQuery-like library, such as Zepto\n"]}