{"version":3,"sources":["meteor://ðŸ’»app/packages/percolate_synced-cron/packages/percolate_synced-cron.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gG","file":"/packages/percolate_synced-cron.js","sourcesContent":["(function () {\n\n/////////////////////////////////////////////////////////////////////////////////////\n//                                                                                 //\n// packages/percolate:synced-cron/synced-cron-server.js                            //\n//                                                                                 //\n/////////////////////////////////////////////////////////////////////////////////////\n                                                                                   //\n// A package for running jobs synchronized across multiple processes               // 1\nSyncedCron = {                                                                     // 2\n  _entries: {},                                                                    // 3\n  running: false,                                                                  // 4\n  options: {                                                                       // 5\n    //Log job run details to console                                               // 6\n    log: true,                                                                     // 7\n                                                                                   // 8\n    logger: null,                                                                  // 9\n                                                                                   // 10\n    //Name of collection to use for synchronisation and logging                    // 11\n    collectionName: 'cronHistory',                                                 // 12\n                                                                                   // 13\n    //Default to using localTime                                                   // 14\n    utc: false,                                                                    // 15\n                                                                                   // 16\n    //TTL in seconds for history records in collection to expire                   // 17\n    //NOTE: Unset to remove expiry but ensure you remove the index from            // 18\n    //mongo by hand                                                                // 19\n    collectionTTL: 172800                                                          // 20\n  },                                                                               // 21\n  config: function(opts) {                                                         // 22\n    this.options = _.extend({}, this.options, opts);                               // 23\n  }                                                                                // 24\n}                                                                                  // 25\n                                                                                   // 26\nLater = Npm.require('later');                                                      // 27\n                                                                                   // 28\n/*                                                                                 // 29\n  Logger factory function. Takes a prefix string and options object                // 30\n  and uses an injected `logger` if provided, else falls back to                    // 31\n  Meteor's `Log` package.                                                          // 32\n                                                                                   // 33\n  Will send a log object to the injected logger, on the following form:            // 34\n                                                                                   // 35\n    message: String                                                                // 36\n    level: String (info, warn, error, debug)                                       // 37\n    tag: 'SyncedCron'                                                              // 38\n*/                                                                                 // 39\nfunction createLogger(prefix) {                                                    // 40\n  check(prefix, String);                                                           // 41\n                                                                                   // 42\n  // Return noop if logging is disabled.                                           // 43\n  if(SyncedCron.options.log === false) {                                           // 44\n    return function() {};                                                          // 45\n  }                                                                                // 46\n                                                                                   // 47\n  return function(level, message) {                                                // 48\n    check(level, Match.OneOf('info', 'error', 'warn', 'debug'));                   // 49\n    check(message, String);                                                        // 50\n                                                                                   // 51\n    var logger = SyncedCron.options && SyncedCron.options.logger;                  // 52\n                                                                                   // 53\n    if(logger && _.isFunction(logger)) {                                           // 54\n                                                                                   // 55\n      logger({                                                                     // 56\n        level: level,                                                              // 57\n        message: message,                                                          // 58\n        tag: prefix                                                                // 59\n      });                                                                          // 60\n                                                                                   // 61\n    } else {                                                                       // 62\n      Log[level]({ message: prefix + ': ' + message });                            // 63\n    }                                                                              // 64\n  }                                                                                // 65\n}                                                                                  // 66\n                                                                                   // 67\nvar log;                                                                           // 68\n                                                                                   // 69\nMeteor.startup(function() {                                                        // 70\n  var options = SyncedCron.options;                                                // 71\n                                                                                   // 72\n  log = createLogger('SyncedCron');                                                // 73\n                                                                                   // 74\n  ['info', 'warn', 'error', 'debug'].forEach(function(level) {                     // 75\n    log[level] = _.partial(log, level);                                            // 76\n  });                                                                              // 77\n                                                                                   // 78\n  // Don't allow TTL less than 5 minutes so we don't break synchronization         // 79\n  var minTTL = 300;                                                                // 80\n                                                                                   // 81\n  // Use UTC or localtime for evaluating schedules                                 // 82\n  if (options.utc)                                                                 // 83\n    Later.date.UTC();                                                              // 84\n  else                                                                             // 85\n    Later.date.localTime();                                                        // 86\n                                                                                   // 87\n  // collection holding the job history records                                    // 88\n  SyncedCron._collection = new Mongo.Collection(options.collectionName);           // 89\n  SyncedCron._collection._ensureIndex({intendedAt: 1, name: 1}, {unique: true});   // 90\n                                                                                   // 91\n  if (options.collectionTTL) {                                                     // 92\n    if (options.collectionTTL > minTTL)                                            // 93\n      SyncedCron._collection._ensureIndex({startedAt: 1 },                         // 94\n        { expireAfterSeconds: options.collectionTTL } );                           // 95\n    else                                                                           // 96\n      log.warn('Not going to use a TTL that is shorter than:' + minTTL);           // 97\n  }                                                                                // 98\n});                                                                                // 99\n                                                                                   // 100\nvar scheduleEntry = function(entry) {                                              // 101\n  var schedule = entry.schedule(Later.parse);                                      // 102\n  entry._timer =                                                                   // 103\n    SyncedCron._laterSetInterval(SyncedCron._entryWrapper(entry), schedule);       // 104\n                                                                                   // 105\n  log.info('Scheduled \"' + entry.name + '\" next run @'                             // 106\n    + Later.schedule(schedule).next(1));                                           // 107\n}                                                                                  // 108\n                                                                                   // 109\n// add a scheduled job                                                             // 110\n// SyncedCron.add({                                                                // 111\n//   name: String, //*required* unique name of the job                             // 112\n//   schedule: function(laterParser) {},//*required* when to run the job           // 113\n//   job: function() {}, //*required* the code to run                              // 114\n// });                                                                             // 115\nSyncedCron.add = function(entry) {                                                 // 116\n  check(entry.name, String);                                                       // 117\n  check(entry.schedule, Function);                                                 // 118\n  check(entry.job, Function);                                                      // 119\n                                                                                   // 120\n  // check                                                                         // 121\n  if (!this._entries[entry.name]) {                                                // 122\n    this._entries[entry.name] = entry;                                             // 123\n                                                                                   // 124\n    // If cron is already running, start directly.                                 // 125\n    if (this.running) {                                                            // 126\n      scheduleEntry(entry);                                                        // 127\n    }                                                                              // 128\n  }                                                                                // 129\n}                                                                                  // 130\n                                                                                   // 131\n// Start processing added jobs                                                     // 132\nSyncedCron.start = function() {                                                    // 133\n  var self = this;                                                                 // 134\n                                                                                   // 135\n  Meteor.startup(function() {                                                      // 136\n    // Schedule each job with later.js                                             // 137\n    _.each(self._entries, function(entry) {                                        // 138\n      scheduleEntry(entry);                                                        // 139\n    });                                                                            // 140\n    self.running = true;                                                           // 141\n  });                                                                              // 142\n}                                                                                  // 143\n                                                                                   // 144\n// Return the next scheduled date of the first matching entry or undefined         // 145\nSyncedCron.nextScheduledAtDate = function(jobName) {                               // 146\n  var entry = this._entries[jobName];                                              // 147\n                                                                                   // 148\n  if (entry)                                                                       // 149\n    return Later.schedule(entry.schedule(Later.parse)).next(1);                    // 150\n}                                                                                  // 151\n                                                                                   // 152\n// Remove and stop the entry referenced by jobName                                 // 153\nSyncedCron.remove = function(jobName) {                                            // 154\n  var entry = this._entries[jobName];                                              // 155\n                                                                                   // 156\n  if (entry) {                                                                     // 157\n    if (entry._timer)                                                              // 158\n      entry._timer.clear();                                                        // 159\n                                                                                   // 160\n    delete this._entries[jobName];                                                 // 161\n    log.info('Removed \"' + entry.name + '\"');                                      // 162\n  }                                                                                // 163\n}                                                                                  // 164\n                                                                                   // 165\n// Pause processing, but do not remove jobs so that the start method will          // 166\n// restart existing jobs                                                           // 167\nSyncedCron.pause = function() {                                                    // 168\n  if (this.running) {                                                              // 169\n    _.each(this._entries, function(entry) {                                        // 170\n      entry._timer.clear();                                                        // 171\n    });                                                                            // 172\n    this.running = false;                                                          // 173\n  }                                                                                // 174\n}                                                                                  // 175\n                                                                                   // 176\n// Stop processing and remove ALL jobs                                             // 177\nSyncedCron.stop = function() {                                                     // 178\n  _.each(this._entries, function(entry, name) {                                    // 179\n    SyncedCron.remove(name);                                                       // 180\n  });                                                                              // 181\n  this.running = false;                                                            // 182\n}                                                                                  // 183\n                                                                                   // 184\n// The meat of our logic. Checks if the specified has already run. If not,         // 185\n// records that it's running the job, runs it, and records the output              // 186\nSyncedCron._entryWrapper = function(entry) {                                       // 187\n  var self = this;                                                                 // 188\n                                                                                   // 189\n  return function(intendedAt) {                                                    // 190\n    intendedAt = new Date(intendedAt.getTime());                                   // 191\n    intendedAt.setMilliseconds(0);                                                 // 192\n                                                                                   // 193\n    var jobHistory = {                                                             // 194\n      intendedAt: intendedAt,                                                      // 195\n      name: entry.name,                                                            // 196\n      startedAt: new Date()                                                        // 197\n    };                                                                             // 198\n                                                                                   // 199\n    // If we have a dup key error, another instance has already tried to run       // 200\n    // this job.                                                                   // 201\n    try {                                                                          // 202\n      jobHistory._id = self._collection.insert(jobHistory);                        // 203\n    } catch(e) {                                                                   // 204\n      // http://www.mongodb.org/about/contributors/error-codes/                    // 205\n      // 11000 == duplicate key error                                              // 206\n      if (e.name === 'MongoError' && e.code === 11000) {                           // 207\n        log.info('Not running \"' + entry.name + '\" again.');                       // 208\n        return;                                                                    // 209\n      }                                                                            // 210\n                                                                                   // 211\n      throw e;                                                                     // 212\n    };                                                                             // 213\n                                                                                   // 214\n    // run and record the job                                                      // 215\n    try {                                                                          // 216\n      log.info('Starting \"' + entry.name + '\".');                                  // 217\n      var output = entry.job(intendedAt); // <- Run the actual job                 // 218\n                                                                                   // 219\n      log.info('Finished \"' + entry.name + '\".');                                  // 220\n      self._collection.update({_id: jobHistory._id}, {                             // 221\n        $set: {                                                                    // 222\n          finishedAt: new Date(),                                                  // 223\n          result: output                                                           // 224\n        }                                                                          // 225\n      });                                                                          // 226\n    } catch(e) {                                                                   // 227\n      log.info('Exception \"' + entry.name +'\" ' + e.stack);                        // 228\n      self._collection.update({_id: jobHistory._id}, {                             // 229\n        $set: {                                                                    // 230\n          finishedAt: new Date(),                                                  // 231\n          error: e.stack                                                           // 232\n        }                                                                          // 233\n      });                                                                          // 234\n    }                                                                              // 235\n  };                                                                               // 236\n}                                                                                  // 237\n                                                                                   // 238\n// for tests                                                                       // 239\nSyncedCron._reset = function() {                                                   // 240\n  this._entries = {};                                                              // 241\n  this._collection.remove({});                                                     // 242\n  this.running = false;                                                            // 243\n}                                                                                  // 244\n                                                                                   // 245\n// ---------------------------------------------------------------------------     // 246\n// The following two functions are lifted from the later.js package, however       // 247\n// I've made the following changes:                                                // 248\n// - Use Meteor.setTimeout and Meteor.clearTimeout                                 // 249\n// - Added an 'intendedAt' parameter to the callback fn that specifies the precise // 250\n//   time the callback function *should* be run (so we can co-ordinate jobs)       // 251\n//   between multiple, potentially laggy and unsynced machines                     // 252\n                                                                                   // 253\n// From: https://github.com/bunkat/later/blob/master/src/core/setinterval.js       // 254\nSyncedCron._laterSetInterval = function(fn, sched) {                               // 255\n                                                                                   // 256\n  var t = SyncedCron._laterSetTimeout(scheduleTimeout, sched),                     // 257\n      done = false;                                                                // 258\n                                                                                   // 259\n  /**                                                                              // 260\n  * Executes the specified function and then sets the timeout for the next         // 261\n  * interval.                                                                      // 262\n  */                                                                               // 263\n  function scheduleTimeout(intendedAt) {                                           // 264\n    if(!done) {                                                                    // 265\n      fn(intendedAt);                                                              // 266\n      t = SyncedCron._laterSetTimeout(scheduleTimeout, sched);                     // 267\n    }                                                                              // 268\n  }                                                                                // 269\n                                                                                   // 270\n  return {                                                                         // 271\n                                                                                   // 272\n    /**                                                                            // 273\n    * Clears the timeout.                                                          // 274\n    */                                                                             // 275\n    clear: function() {                                                            // 276\n      done = true;                                                                 // 277\n      t.clear();                                                                   // 278\n    }                                                                              // 279\n                                                                                   // 280\n  };                                                                               // 281\n                                                                                   // 282\n};                                                                                 // 283\n                                                                                   // 284\n// From: https://github.com/bunkat/later/blob/master/src/core/settimeout.js        // 285\nSyncedCron._laterSetTimeout = function(fn, sched) {                                // 286\n                                                                                   // 287\n  var s = Later.schedule(sched), t;                                                // 288\n  scheduleTimeout();                                                               // 289\n                                                                                   // 290\n  /**                                                                              // 291\n  * Schedules the timeout to occur. If the next occurrence is greater than the     // 292\n  * max supported delay (2147483647 ms) than we delay for that amount before       // 293\n  * attempting to schedule the timeout again.                                      // 294\n  */                                                                               // 295\n  function scheduleTimeout() {                                                     // 296\n    var now = Date.now(),                                                          // 297\n        next = s.next(2, now);                                                     // 298\n                                                                                   // 299\n    // don't schedlue another occurence if no more exist synced-cron#41            // 300\n    if (! next[0])                                                                 // 301\n      return;                                                                      // 302\n                                                                                   // 303\n    var diff = next[0].getTime() - now,                                            // 304\n        intendedAt = next[0];                                                      // 305\n                                                                                   // 306\n    // minimum time to fire is one second, use next occurrence instead             // 307\n    if(diff < 1000) {                                                              // 308\n      diff = next[1].getTime() - now;                                              // 309\n      intendedAt = next[1];                                                        // 310\n    }                                                                              // 311\n                                                                                   // 312\n    if(diff < 2147483647) {                                                        // 313\n      t = Meteor.setTimeout(function() { fn(intendedAt); }, diff);                 // 314\n    }                                                                              // 315\n    else {                                                                         // 316\n      t = Meteor.setTimeout(scheduleTimeout, 2147483647);                          // 317\n    }                                                                              // 318\n  }                                                                                // 319\n                                                                                   // 320\n  return {                                                                         // 321\n                                                                                   // 322\n    /**                                                                            // 323\n    * Clears the timeout.                                                          // 324\n    */                                                                             // 325\n    clear: function() {                                                            // 326\n      Meteor.clearTimeout(t);                                                      // 327\n    }                                                                              // 328\n                                                                                   // 329\n  };                                                                               // 330\n                                                                                   // 331\n};                                                                                 // 332\n// ---------------------------------------------------------------------------     // 333\n                                                                                   // 334\n/////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}