{"version":3,"sources":["meteor://ðŸ’»app/packages/tomi_upload-server/upload_server.js","meteor://ðŸ’»app/packages/tomi_upload-server/router.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wH;;;;;;;;;;;;;;;;;;ACtjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uH","file":"/packages/tomi_upload-server.js","sourcesContent":["var formidable = Npm.require('formidable');\nvar http = Npm.require('http');\nvar sys = Npm.require('sys');\n\n//var connect = Npm.require('connect');\nvar url = Npm.require('url');\nvar path = Npm.require('path');\nvar fs = Npm.require('fs');\nvar Fiber = Npm.require('fibers');\n\nvar _existsSync = fs.existsSync || path.existsSync;\nvar imageMagick = Npm.require('imagemagick');\n\nvar options = {\n  /** @type String*/\n  tmpDir: null,\n  /** @type String*/\n  uploadDir: null,\n  uploadUrl: '/upload/',\n  checkCreateDirectories: false,\n  maxPostSize: 11000000000, // 11 GB\n  minFileSize: 1,\n  maxFileSize: 10000000000, // 10 GB\n  acceptFileTypes: /.+/i,\n  // Files not matched by this regular expression force a download dialog,\n  // to prevent executing any scripts in the context of the service domain:\n  inlineFileTypes: /\\.(gif|jpe?g|png)$/i,\n  imageTypes: /\\.(gif|jpe?g|png)$/i,\n  imageVersions: {\n    thumbnail: {\n      width: 200,\n      height: 200,\n    },\n  },\n  crop: false,\n  overwrite: false,\n  cacheTime: 86400,\n  getDirectory: function (fileInfo, formData) {\n    return \"\"\n  },\n  getFileName: function (fileInfo, formData) {\n    return fileInfo.name;\n  },\n  finished: function () {\n  },\n  validateRequest: function () {\n    return null;\n  },\n  validateFile: function () {\n    return null;\n  },\n  accessControl: {\n    allowOrigin: '*',\n    allowMethods: 'OPTIONS, HEAD, GET, POST, PUT, DELETE',\n    allowHeaders: 'Content-Type, Content-Range, Content-Disposition'\n  },\n  mimeTypes: {\n    \"html\": \"text/html\",\n    \"jpeg\": \"image/jpeg\",\n    \"jpg\": \"image/jpeg\",\n    \"png\": \"image/png\",\n    \"gif\": \"image/gif\",\n    \"js\": \"text/javascript\",\n    \"css\": \"text/css\",\n    \"pdf\": \"application/pdf\",\n    \"doc\": \"application/msword\",\n    \"docx\": \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n    \"zip\": \"application/zip, application/x-compressed-zip\",\n    \"txt\": \"text/plain\"\n  }\n  /* Uncomment and edit this section to provide the service via HTTPS:\n   ssl: {\n   key: fs.readFileSync('/Applications/XAMPP/etc/ssl.key/server.key'),\n   cert: fs.readFileSync('/Applications/XAMPP/etc/ssl.crt/server.crt')\n   },\n   */\n};\n\n\nUploadServer = {\n  getOptions: function()\n  {\n    return options;\n  },\n  init: function (opts) {\n    if (opts.checkCreateDirectories != null) options.checkCreateDirectories = opts.checkCreateDirectories;\n\n    if (opts.tmpDir == null) {\n      throw new Meteor.Error('Temporary directory needs to be assigned!');\n    } else {\n      options.tmpDir = opts.tmpDir;\n    }\n\n    if (opts.cacheTime != null) {\n      options.cacheTime = opts.cacheTime;\n    }\n\n    if (opts.mimeTypes != null) {\n      for (var key in opts.mimeTypes) {\n        options.mimeTypes[key] = opts.mimeTypes[key];\n      }\n    }\n\n    if (opts.checkCreateDirectories) {\n      checkCreateDirectory(options.tmpDir);\n    }\n\n    if (opts.uploadDir == null) {\n      throw new Meteor.Error('Upload directory needs to be assigned!');\n    } else {\n      options.uploadDir = opts.uploadDir;\n    }\n\n    if (opts.uploadUrl) {\n      options.uploadUrl = opts.uploadUrl;\n    }\n\n    if (options.checkCreateDirectories) {\n      checkCreateDirectory(options.uploadDir);\n    }\n\n    if (opts.maxPostSize != null) options.maxPostSize = opts.maxPostSize;\n    if (opts.minFileSize != null) options.minFileSize = opts.minFileSize;\n    if (opts.maxFileSize != null) options.maxFileSize = opts.maxFileSize;\n    if (opts.acceptFileTypes != null) options.acceptFileTypes = opts.acceptFileTypes;\n    if (opts.imageTypes != null) options.imageTypes = opts.imageTypes;\n    if (opts.crop != null) options.crop = opts.crop;\n    if (opts.validateRequest != null) options.validateRequest = opts.validateRequest;\n    if (opts.validateFile != null) options.validateFile = opts.validateFile;\n    if (opts.getDirectory != null) options.getDirectory = opts.getDirectory;\n    if (opts.getFileName != null) options.getFileName = opts.getFileName;\n    if (opts.finished != null) options.finished = opts.finished;\n    if (opts.overwrite != null) options.overwrite = opts.overwrite;\n\n    if (opts.uploadUrl) options.uploadUrl = opts.uploadUrl;\n\n    if (opts.imageVersions != null) options.imageVersions = opts.imageVersions\n    else options.imageVersions = [];\n\n    if (options.uploadUrl != \"/upload/\") {\n      console.log(\"Custom upload url setup to: \" + options.uploadUrl);\n    }\n\n    RoutePolicy.declare(options.uploadUrl, 'network');\n    WebApp.connectHandlers.use(options.uploadUrl, UploadServer.serve);\n  },\n  delete: function (filePath) {\n\n    // make sure paths are correct\n    fs.unlinkSync(path.join(options.uploadDir, filePath));\n    \n    // unlink all imageVersions also\n    if (options.imageVersions) {\n    \tvar subFolders = Object.keys(options.imageVersions);\n \tfor(var i=0; i<subFolders.length; i++) {\n\t    fs.unlinkSync(path.join(options.uploadDir, subFolders[i], filePath));\n \t}\n    }\n  },\n  serve: function (req, res) {\n    if (options.tmpDir == null || options.uploadDir == null) {\n      throw new Meteor.Error('Upload component not initialised!');\n    }\n\n    res.setHeader(\n      'Access-Control-Allow-Origin',\n      options.accessControl.allowOrigin\n    );\n    res.setHeader(\n      'Access-Control-Allow-Methods',\n      options.accessControl.allowMethods\n    );\n    res.setHeader(\n      'Access-Control-Allow-Headers',\n      options.accessControl.allowHeaders\n    );\n    var handleResult = function (result, redirect) {\n        if (redirect) {\n          res.writeHead(302, {\n            'Location': redirect.replace(\n              /%s/,\n              encodeURIComponent(JSON.stringify(result))\n            )\n          });\n          res.end();\n        } else if (result.error) {\n          res.writeHead(403, {'Content-Type': 'text/plain'});\n          res.write(result.error);\n          res.end();\n        } else {\n          //res.writeHead(200, {\n          //  'Content-Type': req.headers.accept\n          //    .indexOf('application/json') !== -1 ?\n          //    'application/json' : 'text/plain'\n          //});\n          res.end(JSON.stringify(result));\n        }\n      },\n      setNoCacheHeaders = function () {\n        if (options.cacheTime) {\n          res.setHeader('Cache-Control', 'public, max-age=' + options.cacheTime);\n        } else {\n          res.setHeader('Pragma', 'no-cache');\n          res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate');\n          // res.setHeader('Content-Disposition', 'inline; filename=\"files.json\"');\n        }\n      },\n      handler = new UploadHandler(req, res, handleResult);\n\n\n    // validate the request\n    var error = options.validateRequest(req, res);\n    if (error == false || (error != true && error != null)) {\n      res.writeHead(403, {'Content-Type': 'text/plain'});\n      res.write(error.toString());\n      res.end();\n      return;\n    }\n\n    switch (req.method) {\n      case 'OPTIONS':\n        res.end();\n        break;\n      case 'HEAD':\n      case 'GET':\n        setNoCacheHeaders();\n\n        var uri = url.parse(req.url).pathname;\n        var filename = path.join(options.uploadDir, unescape(uri));\n        var stats;\n\n        try {\n          stats = fs.lstatSync(filename); // throws if path doesn't exist\n        } catch (e) {\n          res.writeHead(404, {'Content-Type': 'text/plain'});\n          res.write('404 Not Found\\n');\n          res.end();\n          return;\n        }\n\n        if (stats.isFile()) {\n          // path exists, is a file\n          var mimeType = options.mimeTypes[path.extname(filename).split(\".\").reverse()[0]];\n          if (!mimeType) {\n            mimeType = \"application/octet-stream\";\n          }\n          res.writeHead(200, {'Content-Type': mimeType});\n\n          //connect.static(options.uploadDir)(req, res);\n          var fileStream = fs.createReadStream(filename);\n          fileStream.pipe(res);\n\n        } else if (stats.isDirectory()) {\n          // path exists, is a directory\n          res.writeHead(403, {'Content-Type': 'text/plain'});\n          res.write('Access denied');\n          res.end();\n        } else {\n          res.writeHead(500, {'Content-Type': 'text/plain'});\n          res.write('500 Internal server error\\n');\n          res.end();\n        }\n        break;\n      case 'POST':\n        // validate post\n        setNoCacheHeaders();\n        handler.post();\n        break;\n      //case 'DELETE':\n      //  handler.destroy();\n      //  break;\n      default:\n        res.statusCode = 405;\n        res.end();\n    }\n  }\n}\n\nvar utf8encode = function (str) {\n  return unescape(encodeURIComponent(str));\n};\n\nvar nameCountRegexp = /(?:(?: \\(([\\d]+)\\))?(\\.[^.]+))?$/;\n\nvar nameCountFunc = function (s, index, ext) {\n  return ' (' + ((parseInt(index, 10) || 0) + 1) + ')' + (ext || '');\n};\n\n/**\n * @class FileInfo Manages paths for uploaded objects\n */\nvar FileInfo = function (file, req, form) {\n  this.name = file.name;\n  this.path = file.name;\n  this.size = file.size;\n  this.type = file.type;\n\n  this.subDirectory = options.getDirectory(this, form.formFields);\n  this.baseUrl = (options.ssl ? 'https:' : 'http:') + '//' + req.headers.host + options.uploadUrl;\n  this.url = this.baseUrl + (this.subDirectory ? (this.subDirectory + '/') : '') + encodeURIComponent(this.name);\n};\n\nFileInfo.prototype.validate = function () {\n  this.error = null;\n  if (options.minFileSize && options.minFileSize > this.size) {\n    this.error = 'File is too small';\n  } else if (options.maxFileSize && options.maxFileSize < this.size) {\n    this.error = 'File is too big';\n  } else if (!options.acceptFileTypes.test(this.name)) {\n    this.error = 'Filetype not allowed';\n  }\n  return this.error;\n};\n\n// FileInfo.prototype.safeName = function () {\n//   // Prevent directory traversal and creating hidden system files:\n//   this.name = path.basename(this.name).replace(/^\\.+/, '');\n//   // Prevent overwriting existing files:\n//   while (_existsSync(options.uploadDir + '/' + this.name)) {\n//     this.name = this.name.replace(nameCountRegexp, nameCountFunc);\n//   }\n// };\n\nFileInfo.prototype.initUrls = function (req, form) {\n  if (!this.error) {\n    // image\n    var that = this;\n    Object.keys(options.imageVersions).forEach(function (version) {\n      if (_existsSync(\n          options.uploadDir + '/' + version + '/' + that.name\n        )) {\n        that[version + 'Url'] = that.baseUrl + version + '/' +\n        encodeURIComponent(that.name);\n      }\n    });\n  }\n};\n\nvar UploadHandler = function (req, res, callback) {\n  this.req = req;\n  this.res = res;\n  this.callback = callback;\n};\n\nUploadHandler.prototype.post = function () {\n  var handler = this,\n    form = new formidable.IncomingForm(),\n    tmpFiles = [],\n    files = [],\n    map = {},\n    counter = 1,\n    redirect,\n    finish = function (err, stdout) {\n\t\t\tif (err) throw err;\n      counter -= 1;\n      if (!counter) {\n        files.forEach(function (fileInfo) {\n          fileInfo.initUrls(handler.req, form);\n        });\n        handler.callback({files: files}, redirect);\n      }\n    };\n  form.uploadDir = options.tmpDir;\n  form.on('fileBegin', function (name, file) {\n    tmpFiles.push(file.path);\n    var fileInfo = new FileInfo(file, handler.req, form);\n    //fileInfo.safeName();\n\n    map[path.basename(file.path)] = fileInfo;\n    files.push(fileInfo);\n  }).on('field', function (name, value) {\n    if (name === 'redirect') {\n      redirect = value;\n    }\n    // remember all the form fields\n    if (this.formFields == null) {\n      this.formFields = {};\n    }\n    //  console.log('Form field: ' + name + \"-\" + value);\n    this.formFields[name] = value;\n  }).on('file', function (name, file) {\n    var fileInfo = map[path.basename(file.path)];\n    fileInfo.size = file.size;\n\n    // custom validation\n    var error = options.validateFile(file, handler.req);\n    if (error == false || (error != true && error != null)) {\n      handler.res.writeHead(403, {'Content-Type': 'text/plain'});\n      handler.res.write(error == false ? \"validationFailed\" : error);\n      handler.res.end();\n      fs.unlinkSync(file.path);\n      return;\n    }\n\n    // fileinfo validation\n    error = fileInfo.validate();\n    if (error) {\n      // delete file\n      fs.unlinkSync(file.path);\n      // callback with error\n      handler.callback({error: error});\n      return;\n    }\n\n    // we can store files in subdirectories\n    var folder = options.getDirectory(fileInfo, this.formFields);\n\n    // make safe directory, disable all '.'\n    folder.replace(/\\./g, '');\n\n    // check if directory exists, if not, create all the directories\n    var subFolders = folder.split('/');\n    var currentFolder = options.uploadDir;\n\n    for (var i = 0; i < subFolders.length; i++) {\n      currentFolder += '/' + subFolders[i];\n\n      if (!fs.existsSync(currentFolder)) {\n        fs.mkdirSync(currentFolder);\n      }\n    }\n\n    // possibly rename file if needed;\n    var newFileName = options.getFileName(fileInfo, this.formFields);\n\n    // make safe file name\n    newFileName = getSafeName(currentFolder, newFileName);\n\n    // set the file name\n    fileInfo.name = newFileName;\n    fileInfo.path = folder + \"/\" + newFileName;\n\n\t\tvar imageVersionsFunc = function() {\n\t\t\tif (options.imageTypes.test(fileInfo.name)) {\n\t      Object.keys(options.imageVersions).forEach(function (version) {\n\t        counter += 1;\n\t        var opts = options.imageVersions[version];\n\n\t        // check if version directory exists\n\t        if (!fs.existsSync(currentFolder + version)) {\n\t          fs.mkdirSync(currentFolder + version);\n\t        }\n\n\t        var ioptions = {\n\t          srcPath: currentFolder + newFileName,\n\t          dstPath: currentFolder + version + '/' + newFileName\n\t        };\n\n\t        if (opts.width) {\n\t          ioptions.width = opts.width;\n\t        }\n\n\t        if (opts.height) {\n\t          ioptions.height = opts.height;\n\t        }\n\n            if (options.crop) {\n              ioptions.quality = 1;\n              ioptions.gravity = 'Center';\n              imageMagick.crop(ioptions, finish);\n            } else {\n              imageMagick.resize(ioptions, finish);\n            }\n\t      });\n\t    }\n\t\t};\n\n    // Move the file to the final destination\n    var destinationFile = currentFolder + newFileName;\n    try\n    {\n     \t// Try moving through renameSync\n       \tfs.renameSync(file.path, destinationFile);\n\t\t\t\timageVersionsFunc();\n    }\n    catch(exception)\n    {\n    \t// if moving failed, try a copy + delete instead, this to support moving work between partitions\n    \tvar is = fs.createReadStream(file.path);\n\t\tvar os = fs.createWriteStream(destinationFile);\n\t\tis.pipe(os);\n\t\tis.on('end',function() {\n    \t\tfs.unlinkSync(file.path);\n\t\t\t\timageVersionsFunc();\n\t\t});\n    }\n\n    // call the feedback within its own fiber\n    var formFields = this.formFields;\n    Fiber(function () {\n      options.finished(fileInfo, formFields);\n    }).run();\n\n  }).on('aborted', function () {\n    tmpFiles.forEach(function (file) {\n      fs.unlink(file);\n    });\n  }).on('error', function (e) {\n    console.log('ERROR');\n    console.log(e);\n  }).on('progress', function (bytesReceived, bytesExpected) {\n    if (bytesReceived > options.maxPostSize) {\n      handler.req.connection.destroy();\n    }\n  }).on('end', finish).parse(handler.req);\n};\n\nUploadHandler.prototype.destroy = function () {\n  var handler = this,\n    fileName;\n  if (handler.req.url.slice(0, options.uploadUrl.length) === options.uploadUrl) {\n    fileName = path.basename(decodeURIComponent(handler.req.url));\n    if (fileName[0] !== '.') {\n      fs.unlink(options.uploadDir + '/' + fileName, function (ex) {\n        Object.keys(options.imageVersions).forEach(function (version) {\n          fs.unlink(options.uploadDir + '/' + version + '/' + fileName);\n        });\n        handler.callback({success: !ex});\n      });\n      return;\n    }\n  }\n  handler.callback({success: false});\n};\n\n// create directories\n\nvar checkCreateDirectory = function (dir) {\n  if (!dir) {\n    return;\n  }\n\n  // If we're on Windows we'll remove the drive letter\n  if(/^win/.test(process.platform)) {\n  \tdir = dir.replace(/([A-Z]:[\\\\\\/]).*?/gi, '')\n  }\n\n  var dirParts = dir.split('/');\n  var currentDir = '/';\n\n  for (var i = 0; i < dirParts.length; i++) {\n    if (!dirParts[i]) {\n      continue;\n    }\n\n    currentDir += dirParts[i] + '/';\n\n    if (!fs.existsSync(currentDir)) {\n      fs.mkdirSync(currentDir);\n      console.log('Created directory: ' + currentDir);\n    }\n  }\n}\n\nvar getSafeName = function(directory, fileName) {\n\tvar n = fileName;\n\t// Prevent directory traversal and creating hidden system files:\n\tn = path.basename(n).replace(/^\\.+/, '');\n\t// Prevent overwriting existing files:\n\tif (!options.overwrite) {\n  \twhile (_existsSync(directory + '/' + n)) {\n  \t\tn = n.replace(nameCountRegexp, nameCountFunc);\n  \t}\n  }\n\treturn n;\n}\n","//Router.route('/upload', function () {\n//  var req = this.request;\n//  var res = this.response;\n//\n//  console.log('doing something');\n//\n//  UploadServer.serve(req, res);\n//}, { where: 'server' });\n\n\n//Router.map(function () {\n//  this.route('upload', {\n//    path: '/upload/(.*)',\n//    where: 'server',\n//    action: function() {\n//      UploadServer.serve(this.request, this.response);\n//    }\n//  });\n//});"]}